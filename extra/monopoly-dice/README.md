# monopoly-dice

**Description**: I was playing monopoly with some friends the other night and was surprised at how often people kept landing on the very same property they had bought the previous turn. This happened 4 or 5 times before I decided that the odds of landing on the same space during consecutive revolutions of the board must be higher than the ratio of 1 to the number of spaces (1/40, or 2.5%). I went home later to model the problem in Haskell. This has nothing to do with the book that this repo is covering, but it is related to learning Haskell and maybe we can benefit as a group from studying this problem if anyone else is interested.

**Results**: My initial suspicion was correct; the probability is higher than 2.5%. The real things to look at are the dice rolls. When a player is within 2 - 12 spaces of a target space then they have, on average, about a 9% chance to land on target. Similarly they have, on average, about a 45.5% to not overshoot their target. This means that the chance of landing on the same tile you are currently on during the next revolution is about 9%, if you don't account for multiple attempts during the same revolution. The actual chance will be higher because of the many chances to roll again before passing the target space and leaving the 2d6 window. The very slight chance to miss the window by landing 13 spaces away and rolling a 12 also factors in there. That is as far as I got before deciding that I needed to actually simulate the process to see if my model was correct. The simulations (in both Python and Haskell) agree on a chance of about 14.28% to land on a space during consecutive revolutions. That is much higher than 2.5%!

**Next**: I wrote this first in Haskell, and while it was a pleasure to build the model in Haskell it was considerably more difficult to put the actual simulation together. I am still trying to figure out the best way to use Monads. I thought I had come up with a pretty elegant way of doing it but if you try to give the Haskell version an input of, say, 1,000,000,000 rolls to simulate then it will crash. I am pretty sure it has something to do with the garbage collector and would love some feedback on how to make it run indefinitely. There should be no limit to how many rolls I can simulate and I was a little disheartened to see Haskell eating up all my RAM on large inputs. To double-check things I re-wrote the problem in Python using nearly the same logic. The Python version is noticeably slower on my machine, but can handle arbitrarily large inputs without crashing (which is kind of important). I am a big fan of Haskell and feel like the problem is better expressed in that language, although I love both of these languages very much. I would like to improve the Haskell version until it is as stable as the Python one. I would also like to improve the non-simulated part of the model so that it accurately accounts for the re-rolls and the chance to miss the 2 - 12 space window, and matches up with the results of the simulation. I am not an expert in the areas of probability that this problem lives in, so I am unsure how to go beyond the averages of probabilities that I've come up with so far and factor in the re-rolls, and the chance to "skip" the window, so that the formulas get the same results as the simulation.

**Instructions**: 
1. Clone this repository.
2. Have Stack installed.
3. While in the `monopoly-dice/` directory, enter `stack init` in the command line.
4. Enter `stack build` in the command line.
5. Enter `stack exec -- monopoly-dice` in the command line.
- To run the python version, type `python3 monopoly_dice.py` or run `./monopoly_dice.py` as an executable with permissions.

